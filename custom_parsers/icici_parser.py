# Auto-generated by agent.py for target="icici"
from __future__ import annotations
from pathlib import Path
import pandas as pd
import numpy as np

# Import shared helpers (keeps this file small)
try:
    from .base_parser import (
        DATE_PATTERNS,
        maybe_date,
        normalize_amount,
        clean_desc,
        coerce_to_expected_date_format,
        extract_tables_pdfplumber,
        extract_lines_pdf,
        build_df_from_tables,
        build_df_from_lines,
    )
except Exception:
    from custom_parsers.base_parser import (
        DATE_PATTERNS,
        maybe_date,
        normalize_amount,
        clean_desc,
        coerce_to_expected_date_format,
        extract_tables_pdfplumber,
        extract_lines_pdf,
        build_df_from_tables,
        build_df_from_lines,
    )

# Backwards compatibility wrappers for tests/monkeypatching
def _extract_tables_pdfplumber(pdf_path: Path):
    return extract_tables_pdfplumber(pdf_path)

def _extract_lines(pdf_path: Path):
    return extract_lines_pdf(pdf_path)

# Main parsing function
def parse(pdf_path: str) -> pd.DataFrame:
    pdf = Path(pdf_path)
    bank = pdf.parent.name

    # Load expected CSV (result.csv or <bank>.csv)
    exp = None
    for c in [pdf.parent / "result.csv", pdf.parent / f"{bank}.csv"]:
        if c.exists():
            exp = pd.read_csv(c)
            break
    if exp is None:
        raise FileNotFoundError("Expected CSV not found next to PDF")

    expected_columns = list(exp.columns)
    expected_dtypes = exp.dtypes.to_dict()

    # Try table extraction first, then fall back to line parsing
    tables = _extract_tables_pdfplumber(pdf)
    df = build_df_from_tables(tables, expected_columns)
    if df is None or df.empty:
        lines = _extract_lines(pdf)
        df = build_df_from_lines(lines, expected_columns)

    # Filter out header/footer rows by keeping only rows with dates
    date_col = expected_columns[0]
    df = df[df[date_col].astype(str).str.match("|".join(DATE_PATTERNS), na=False)]

    # --- [PATCHPOINT:REINDEX] ---
    df = df.reindex(columns=expected_columns)
    # --- [/PATCHPOINT:REINDEX] ---

    # Make date format match expected CSV
    if date_col in expected_dtypes:
        df[date_col] = coerce_to_expected_date_format(df[date_col], exp[date_col])

    # Cast to expected types for exact matching
    for col in df.columns:
        if col in expected_dtypes and "float" in str(expected_dtypes[col]):
            # --- [PATCHPOINT:NUMERIC_CAST] ---
            df[col] = df[col].map(normalize_amount).astype("float64")
            # --- [/PATCHPOINT:NUMERIC_CAST] ---
        else:
            df[col] = df[col].astype("object").astype(str).str.strip()

    # --- [PATCHPOINT:CLEANUP] ---
    df = df.reset_index(drop=True)
    return df
    # --- [/PATCHPOINT:CLEANUP] ---
